//
//  main.c
//  ShellSort
//
//  Created by 郝赟 on 16/6/1.
//  Copyright © 2016年 haoyun. All rights reserved.
/********************************************************
*分析:是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有
*     序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。
*思想：将无序数组分割为若干个子序列，子序列不是逐段分割的，而是相隔特定的增量的子序列，对各个子序列进行插入排序；然后再选择一个
*     更小的增量，再将数组分割为多个子序列进行排序......最后选择增量为1，即使用直接插入排序，使最终数组成为有序。
*稳定性:由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在
*     各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。
*********************************************************/
#include <stdio.h>
/********************************************************
 *函数名称：ShellInsert
 *参数说明：pDataArray 无序数组；
 *          d          增量大小
 *          iDataNum为无序数据个数
 *说明：    希尔按增量d的插入排序
 *********************************************************/
void shellInsert(int data[], int d, int length){
    for (int i = d; i < length; i++) { //增量为d,从第d+1个数开始，前d个数看做d趟排序的第一个数
        int j = i - d;
        int temp = data[i];//记录要插入的数
        while (j >= 0 && data[j] > temp) { //从后往前，找到比要插入的数还小的数的位置
            data[j+d] = data[j]; //如果这个数比要插入的数大，就将它向后移动到增量d的位置
            j -= d;
        }
        if (j != i -d) {//如果存在比要插入的数大的数，就将要插入的数插入到最后一次没有移动的地方
            data[j+d] = temp;
        }
    }
}
void shellSort(int data[], int length){
    int d = length / 2;
    while (d >= 1) {
        shellInsert(data,d,length);
        d = d / 2; //每次增量变为原来的一半
    }
}
int main(int argc, const char * argv[]) {
    int sortArray[] = {21,2,1,45,2,14,32,14,21,45,32,14,2,9,8,75,6,52,4,6};
    shellSort(sortArray, 20);
    for (int i = 0; i < 20; i ++) {
        printf("%d ",sortArray[i]);
    }
    printf("\n");
    return 0;
}
